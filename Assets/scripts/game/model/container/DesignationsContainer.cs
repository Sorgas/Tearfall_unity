using System;
using System.Collections.Generic;
using game.model.localmap;
using game.model.localmap.passage;
using Leopotam.Ecs;
using UnityEngine;
using UnityEngine.UI;
using util.lang;

namespace game.model.container {
    public class DesignationsContainer {
        public readonly Dictionary<Vector3Int, EcsEntity> designations = new Dictionary<Vector3Int, EcsEntity>();
        
        // public readonly Dictionary<string, TaskList> tasks; // task job to all tasks with this job
        // public readonly Set<Task> assignedTasks; // tasks, taken by some unit.
        // // public readonly HashMap<IntVector3, Designation> designations; //this map is for rendering and modifying designations
        // public readonly DesignationSystem designationSystem;
        // public readonly TaskStatusSystem taskStatusSystem;

        // private PassageMap map;

        public DesignationsContainer() {
            // tasks = new HashMap<>();
            // JobMap.all().forEach(job->tasks.put(job.name, new TaskList()));
            // assignedTasks = new HashSet<>();
            // designationSystem = new DesignationSystem(this);
            // taskStatusSystem = new TaskStatusSystem(this);
        }
        
     //    public void update(TimeUnitEnum unit) {
     //        designationSystem.update();
     //        taskStatusSystem.update();
     //        tasks.values().forEach(list->list.update(unit));
     //    }
     //
     //    /**
     // * Gets tasks for unit. Filters task by units's allowed jobs.
     // * Does not assign task to unit, because after this method is compared to unit's other tasks, see {@link stonering.game.model.system.unit.CreaturePlanningSystem}.
     // * TODO consider task priority
     // */
     //    public Task getActiveTask(CanvasScaler.Unit unit) {
     //        List<String> enabledJobs = new ArrayList<>();
     //        enabledJobs.add("none");
     //        unit.optional(JobSkillAspect.class).ifPresent(aspect->enabledJobs.addAll(aspect.enabledJobs));
     //        return tasks.keySet().stream()
     //            .filter(enabledJobs::contains)
     //            .map(tasks::get)
     //            .flatMap(taskList->taskList.tasks.stream())
     //            .filter(task->taskTargetReachable(unit, task)) // tasks with reachable targets
     //            .min(Comparator.comparingInt(task->task.initialAction.target.getPosition().fastDistance(unit.position))) // nearest target
     //            .orElse(null);
     //    }
     //
     //    /**
     // * Moves given task to set of taken tasks, making it unavailable for units to take.
     // * If task was generated by unit (e.g. need), does nothing.
     // */
     //    public void claimTask(@NotNull Task task) {
     //        if (tasks.get(task.job).remove(task)) {
     //            assignedTasks.add(task);
     //            Logger.TASKS.logDebug("task " + task + " claimed.");
     //        } else {
     //            Logger.TASKS.logError("claimed task " + task + " is not in open tasks.");
     //        }
     //    }
     //
     //    public void addTask(Task task) {
     //        Optional<>.ofNullable(task)
     //            .map(task1->tasks.get(task1.job))
     //            .ifPresent(list-> {
     //            list.add(task);
     //            if (task.designation != null) designations.put(task.designation.position, task.designation);
     //            Logger.TASKS.logDebug("Task " + task + " added to TaskContainer.");
     //        });
     //    }
     //
     //    /**
     // * Task should have no performer.
     // */
     //    public void reopenTask(@Nonnull Task task) {
     //        task.reset(); // delete actions
     //        assignedTasks.remove(task);
     //        tasks.get(task.job).reopen(task);
     //    }
     //
     //    public void removeTask(@Nonnull Task task) {
     //        if (task.designation != null) designations.remove(task.designation.position);
     //        assignedTasks.remove(task);
     //        tasks.get(task.job).remove(task);
     //    }
     //
     //    private boolean taskTargetReachable(CanvasScaler.Unit unit, Task task) {
     //        return map().util.positionReachable(unit.position, task.initialTarget().getPosition(), task.initialTarget().type != EXACT);
     //    }
     //
     //    private PassageMap map() {
     //        return map == null ? map = GameMvc.model().get(LocalMap.class).passageMap :
     //        map;
     //    }
    } 
}