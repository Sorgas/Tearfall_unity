using System.Collections.Generic;
using enums.action;
using game.model.component;
using game.model.component.task;
using Leopotam.Ecs;
using types;
using types.building;
using UnityEngine;
using util.lang.extension;
using static UnityEngine.Object;

namespace game.model.container {
    // registry of designation entities, creates and destroys designations, called by ECS systems
    // TODO allow multiple designation on one tile
    public class DesignationContainer {
        public readonly Dictionary<Vector3Int, EcsEntity> designations = new();
        
        public void createDesignation(Vector3Int position, DesignationType type) {
            EcsEntity entity = GameModel.get().createEntity();
            entity.Replace(new DesignationComponent { type = type });
            addDesignation(entity, position);
        }

        public void createConstructionDesignation(Vector3Int position, ConstructionType type, string itemType, int material) {
            EcsEntity entity = GameModel.get().createEntity();
            entity.Replace(new DesignationComponent { type = DesignationTypes.D_CONSTRUCT });
            entity.Replace(new DesignationConstructionComponent { type = type, itemType = itemType, material = material });
            entity.Replace(new DesignationItemContainerComponent { items = new List<EcsEntity>() });
            addDesignation(entity, position);
            Debug.Log("Construction designation created " + position);
        }

        private void addDesignation(EcsEntity entity, Vector3Int position) {
            entity.Replace(new PositionComponent { position = position });
            if (designations.ContainsKey(position)) {
                // replace previous designation
                cancelDesignation(position); // cancel previous designation
            }
            designations[position] = entity;
        }

        // removes designation in given position
        public void removeDesignation(Vector3Int position) {
            if (designations.ContainsKey(position)) {
                removeDesignation(designations[position]);
            } else {
                Debug.LogWarning("deleting designation by position " + position + " unregistered in DesignationContainer");
            }
        }

        // use only when task is completed! 
        public void removeDesignation(EcsEntity designation) {
            designations.Remove(designation.pos());
            if (designation.Has<DesignationVisualComponent>()) {
                Destroy(designation.Get<DesignationVisualComponent>().spriteRenderer.gameObject);
                designation.Del<DesignationVisualComponent>();
            } else {
                Debug.LogWarning("deleting designation without DesignationVisualComponent");
            }

            designation.Destroy();
        }

        // mark designation as canceled. will be handled in DesignationCompletionSystem
        public void cancelDesignation(Vector3Int position) {
            addFinishedComponent(position, TaskStatusEnum.CANCELED);
        }

        private void addFinishedComponent(Vector3Int position, TaskStatusEnum status) {
            if (designations.ContainsKey(position)) {
                designations[position].Replace(new TaskFinishedComponent { status = TaskStatusEnum.CANCELED });
            }
        }

        //    public void update(TimeUnitEnum unit) {
        //        designationSystem.update();
        //        taskStatusSystem.update();
        //        tasks.values().forEach(list->list.update(unit));
        //    }
        //
        //    /**
        // * Gets tasks for unit. Filters task by units's allowed jobs.
        // * Does not assign task to unit, because after this method is compared to unit's other tasks, see {@link stonering.game.model.system.unit.CreaturePlanningSystem}.
        // * TODO consider task priority
        // */
        //    public Task getActiveTask(CanvasScaler.Unit unit) {
        //        List<String> enabledJobs = new ArrayList<>();
        //        enabledJobs.add("none");
        //        unit.optional(JobSkillAspect.class).ifPresent(aspect->enabledJobs.addAll(aspect.enabledJobs));
        //        return tasks.keySet().stream()
        //            .filter(enabledJobs::contains)
        //            .map(tasks::get)
        //            .flatMap(taskList->taskList.tasks.stream())
        //            .filter(task->taskTargetReachable(unit, task)) // tasks with reachable targets
        //            .min(Comparator.comparingInt(task->task.initialAction.target.getPosition().fastDistance(unit.position))) // nearest target
        //            .orElse(null);
        //    }
        //
        //    /**
        // * Moves given task to set of taken tasks, making it unavailable for units to take.
        // * If task was generated by unit (e.g. need), does nothing.
        // */
        //    public void claimTask(@NotNull Task task) {
        //        if (tasks.get(task.job).remove(task)) {
        //            assignedTasks.add(task);
        //            Logger.TASKS.logDebug("task " + task + " claimed.");
        //        } else {
        //            Logger.TASKS.logError("claimed task " + task + " is not in open tasks.");
        //        }
        //    }
        //
        //    public void addTask(Task task) {
        //        Optional<>.ofNullable(task)
        //            .map(task1->tasks.get(task1.job))
        //            .ifPresent(list-> {
        //            list.add(task);
        //            if (task.designation != null) designations.put(task.designation.position, task.designation);
        //            Logger.TASKS.logDebug("Task " + task + " added to TaskContainer.");
        //        });
        //    }
        //
        //    /**
        // * Task should have no performer.
        // */
        //    public void reopenTask(@Nonnull Task task) {
        //        task.reset(); // delete actions
        //        assignedTasks.remove(task);
        //        tasks.get(task.job).reopen(task);
        //    }
        //
        //    public void removeTask(@Nonnull Task task) {
        //        if (task.designation != null) designations.remove(task.designation.position);
        //        assignedTasks.remove(task);
        //        tasks.get(task.job).remove(task);
        //    }
        //
        //    private boolean taskTargetReachable(CanvasScaler.Unit unit, Task task) {
        //        return map().util.positionReachable(unit.position, task.initialTarget().getPosition(), task.initialTarget().type != EXACT);
        //    }
    }
}